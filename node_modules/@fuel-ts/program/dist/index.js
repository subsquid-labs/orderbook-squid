"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Contract: () => Contract,
  FunctionInvocationResult: () => FunctionInvocationResult,
  FunctionInvocationScope: () => FunctionInvocationScope,
  InstructionSet: () => InstructionSet,
  InvocationCallResult: () => InvocationCallResult,
  InvocationResult: () => InvocationResult,
  MultiCallInvocationScope: () => MultiCallInvocationScope,
  ScriptRequest: () => ScriptRequest,
  assert: () => assert,
  getAbisFromAllCalls: () => getAbisFromAllCalls
});
module.exports = __toCommonJS(src_exports);

// src/utils.ts
var import_errors = require("@fuel-ts/errors");
function assert(condition, message) {
  if (!condition) {
    throw new import_errors.FuelError(import_errors.ErrorCode.TRANSACTION_ERROR, message);
  }
}
function getAbisFromAllCalls(functionScopes) {
  return functionScopes.reduce((acc, funcScope, i) => {
    const { program, externalAbis } = funcScope.getCallConfig();
    if (i === 0) {
      acc.main = program.interface.jsonAbi;
      acc.otherContractsAbis = {};
    } else {
      acc.otherContractsAbis[program.id.toB256()] = program.interface.jsonAbi;
    }
    acc.otherContractsAbis = { ...acc.otherContractsAbis, ...externalAbis };
    return acc;
  }, {});
}

// src/functions/invocation-scope.ts
var import_account4 = require("@fuel-ts/account");
var import_errors5 = require("@fuel-ts/errors");

// src/functions/base-invocation-scope.ts
var import_account3 = require("@fuel-ts/account");
var import_address = require("@fuel-ts/address");
var import_errors4 = require("@fuel-ts/errors");
var import_math3 = require("@fuel-ts/math");
var import_transactions4 = require("@fuel-ts/transactions");
var import_utils5 = require("@fuel-ts/utils");
var asm2 = __toESM(require("@fuels/vm-asm"));
var import_ramda = require("ramda");

// src/contract-call-script.ts
var import_abi_coder2 = require("@fuel-ts/abi-coder");
var import_configs = require("@fuel-ts/address/configs");
var import_errors3 = require("@fuel-ts/errors");
var import_math = require("@fuel-ts/math");
var import_transactions2 = require("@fuel-ts/transactions");
var import_utils3 = require("@fuel-ts/utils");
var asm = __toESM(require("@fuels/vm-asm"));

// src/instruction-set.ts
var import_utils = require("@fuel-ts/utils");
var InstructionSet = class {
  #operations;
  constructor(...args) {
    this.#operations = args || [];
  }
  entries() {
    return this.#operations;
  }
  push(...args) {
    this.#operations.push(...args);
  }
  concat(ops) {
    return this.#operations.concat(ops);
  }
  extend(ops) {
    this.#operations.push(...ops);
  }
  toBytes() {
    return (0, import_utils.concat)(
      this.#operations.reduce((instructions, line) => {
        instructions.push(line.to_bytes());
        return instructions;
      }, [])
    );
  }
  toHex() {
    return (0, import_utils.hexlify)(this.toBytes());
  }
  toString() {
    return `Program:
${JSON.stringify(this.#operations, null, 2)}`;
  }
  byteLength() {
    return this.toBytes().byteLength;
  }
};

// src/script-request.ts
var import_abi_coder = require("@fuel-ts/abi-coder");
var import_account = require("@fuel-ts/account");
var import_errors2 = require("@fuel-ts/errors");
var import_transactions = require("@fuel-ts/transactions");
var import_utils2 = require("@fuel-ts/utils");
var calculateScriptDataBaseOffset = (maxInputs) => import_abi_coder.SCRIPT_FIXED_SIZE + (0, import_abi_coder.calculateVmTxMemory)({ maxInputs });
var POINTER_DATA_OFFSET = import_abi_coder.WORD_SIZE + import_abi_coder.ASSET_ID_LEN + import_abi_coder.CONTRACT_ID_LEN + import_abi_coder.WORD_SIZE + import_abi_coder.WORD_SIZE;
function callResultToScriptResult(callResult) {
  const receipts = [...callResult.receipts];
  let scriptResultReceipt;
  let returnReceipt;
  receipts.forEach((receipt) => {
    if (receipt.type === import_transactions.ReceiptType.ScriptResult) {
      scriptResultReceipt = receipt;
    } else if (receipt.type === import_transactions.ReceiptType.Return || receipt.type === import_transactions.ReceiptType.ReturnData || receipt.type === import_transactions.ReceiptType.Revert) {
      returnReceipt = receipt;
    }
  });
  if (!scriptResultReceipt || !returnReceipt) {
    throw new import_errors2.FuelError(import_errors2.ErrorCode.SCRIPT_REVERTED, `Transaction reverted.`);
  }
  const scriptResult = {
    code: scriptResultReceipt.result,
    gasUsed: scriptResultReceipt.gasUsed,
    receipts,
    scriptResultReceipt,
    returnReceipt,
    callResult
  };
  return scriptResult;
}
function decodeCallResult(callResult, decoder, logs = []) {
  try {
    const scriptResult = callResultToScriptResult(callResult);
    return decoder(scriptResult);
  } catch (error) {
    if (error.code === import_errors2.ErrorCode.SCRIPT_REVERTED) {
      const statusReason = callResult?.dryRunStatus?.reason;
      throw (0, import_account.extractTxError)({
        logs,
        receipts: callResult.receipts,
        statusReason
      });
    }
    throw error;
  }
}
function callResultToInvocationResult(callResult, call2, logs) {
  return decodeCallResult(
    callResult,
    (scriptResult) => {
      if (scriptResult.returnReceipt.type === import_transactions.ReceiptType.Revert) {
        throw new import_errors2.FuelError(
          import_errors2.ErrorCode.SCRIPT_REVERTED,
          `Script Reverted. Logs: ${JSON.stringify(logs)}`
        );
      }
      if (scriptResult.returnReceipt.type !== import_transactions.ReceiptType.Return && scriptResult.returnReceipt.type !== import_transactions.ReceiptType.ReturnData) {
        const { type } = scriptResult.returnReceipt;
        throw new import_errors2.FuelError(
          import_errors2.ErrorCode.SCRIPT_REVERTED,
          `Script Return Type [${type}] Invalid. Logs: ${JSON.stringify({
            logs,
            receipt: scriptResult.returnReceipt
          })}`
        );
      }
      let value;
      if (scriptResult.returnReceipt.type === import_transactions.ReceiptType.Return) {
        value = scriptResult.returnReceipt.val;
      }
      if (scriptResult.returnReceipt.type === import_transactions.ReceiptType.ReturnData) {
        const decoded = call2.func.decodeOutput(scriptResult.returnReceipt.data);
        value = decoded[0];
      }
      return value;
    },
    logs
  );
}
var ScriptRequest = class {
  /**
   * The bytes of the script.
   */
  bytes;
  /**
   * A function to encode the script data.
   */
  scriptDataEncoder;
  /**
   * A function to decode the script result.
   */
  scriptResultDecoder;
  /**
   * Creates an instance of the ScriptRequest class.
   *
   * @param bytes - The bytes of the script.
   * @param scriptDataEncoder - The script data encoder function.
   * @param scriptResultDecoder - The script result decoder function.
   */
  constructor(bytes, scriptDataEncoder, scriptResultDecoder2) {
    this.bytes = (0, import_utils2.arrayify)(bytes);
    this.scriptDataEncoder = scriptDataEncoder;
    this.scriptResultDecoder = scriptResultDecoder2;
  }
  /**
   * Gets the script data offset for the given bytes.
   *
   * @param byteLength - The byte length of the script.
   * @param maxInputs - The maxInputs value from the chain's consensus params.
   * @returns The script data offset.
   */
  static getScriptDataOffsetWithScriptBytes(byteLength, maxInputs) {
    const scriptDataBaseOffset = (0, import_abi_coder.calculateVmTxMemory)({ maxInputs }) + import_abi_coder.SCRIPT_FIXED_SIZE;
    return scriptDataBaseOffset + byteLength;
  }
  /**
   * Gets the script data offset.
   *
   * @param maxInputs - The maxInputs value from the chain's consensus params.
   * @returns The script data offset.
   */
  getScriptDataOffset(maxInputs) {
    return ScriptRequest.getScriptDataOffsetWithScriptBytes(this.bytes.length, maxInputs);
  }
  /**
   * Encodes the data for a script call.
   *
   * @param data - The script data.
   * @returns The encoded data.
   */
  encodeScriptData(data) {
    const callScript = this.scriptDataEncoder(data);
    if (ArrayBuffer.isView(callScript)) {
      return callScript;
    }
    this.bytes = (0, import_utils2.arrayify)(callScript.script);
    return callScript.data;
  }
  /**
   * Decodes the result of a script call.
   *
   * @param callResult - The CallResult from the script call.
   * @param logs - Optional logs associated with the decoding.
   * @returns The decoded result.
   */
  decodeCallResult(callResult, logs = []) {
    return decodeCallResult(callResult, this.scriptResultDecoder, logs);
  }
};

// src/contract-call-script.ts
var DEFAULT_OPCODE_PARAMS = {
  assetIdOffset: 0,
  amountOffset: 0,
  gasForwardedOffset: 0,
  callDataOffset: 0
};
var SCRIPT_WRAPPER_CONTRACT_ID = import_configs.ZeroBytes32;
var getSingleCallInstructions = ({
  callDataOffset,
  gasForwardedOffset,
  amountOffset,
  assetIdOffset
}) => {
  const inst = new InstructionSet(
    asm.movi(16, callDataOffset),
    asm.movi(17, amountOffset),
    asm.lw(17, 17, 0),
    asm.movi(18, assetIdOffset)
  );
  if (gasForwardedOffset) {
    inst.push(
      asm.movi(19, gasForwardedOffset),
      asm.lw(19, 19, 0),
      asm.call(16, 17, 18, 19)
    );
  } else {
    inst.push(asm.call(16, 17, 18, asm.RegId.cgas().to_u8()));
  }
  return inst;
};
function getInstructions(offsets) {
  if (!offsets.length) {
    return new Uint8Array();
  }
  const multiCallInstructions = new InstructionSet();
  for (let i = 0; i < offsets.length; i += 1) {
    multiCallInstructions.extend(getSingleCallInstructions(offsets[i]).entries());
  }
  multiCallInstructions.push(asm.ret(1));
  return multiCallInstructions.toBytes();
}
var isReturnType = (type) => type === import_transactions2.ReceiptType.Return || type === import_transactions2.ReceiptType.ReturnData;
var getMainCallReceipt = (receipts, contractId) => receipts.find(
  ({ type, from, to }) => type === import_transactions2.ReceiptType.Call && from === SCRIPT_WRAPPER_CONTRACT_ID && to === contractId
);
var scriptResultDecoder = (contractId) => (result) => {
  if ((0, import_math.toNumber)(result.code) !== 0) {
    throw new import_errors3.FuelError(import_errors3.ErrorCode.SCRIPT_REVERTED, `Transaction reverted.`);
  }
  const mainCallResult = getMainCallReceipt(
    result.receipts,
    contractId.toB256()
  );
  const mainCallInstructionStart = (0, import_math.bn)(mainCallResult?.is);
  const receipts = result.receipts;
  return receipts.filter(({ type }) => isReturnType(type)).flatMap((receipt) => {
    if (!mainCallInstructionStart.eq((0, import_math.bn)(receipt.is))) {
      return [];
    }
    if (receipt.type === import_transactions2.ReceiptType.Return) {
      return [new import_abi_coder2.BigNumberCoder("u64").encode(receipt.val)];
    }
    if (receipt.type === import_transactions2.ReceiptType.ReturnData) {
      const encodedScriptReturn = (0, import_utils3.arrayify)(receipt.data);
      return [encodedScriptReturn];
    }
    return [new Uint8Array()];
  });
};
var decodeContractCallScriptResult = (callResult, contractId, logs = []) => decodeCallResult(callResult, scriptResultDecoder(contractId), logs);
var getCallInstructionsLength = (contractCalls) => contractCalls.reduce(
  (sum, call2) => {
    const offset = { ...DEFAULT_OPCODE_PARAMS };
    if (call2.gas) {
      offset.gasForwardedOffset = 1;
    }
    return sum + getSingleCallInstructions(offset).byteLength();
  },
  asm.Instruction.size()
  // placeholder for single RET instruction which is added later
);
var getContractCallScript = (functionScopes, maxInputs) => new ScriptRequest(
  // Script to call the contract, start with stub size matching length of calls
  getInstructions(new Array(functionScopes.length).fill(DEFAULT_OPCODE_PARAMS)),
  (contractCalls) => {
    const TOTAL_CALLS = contractCalls.length;
    if (TOTAL_CALLS === 0) {
      return { data: new Uint8Array(), script: new Uint8Array() };
    }
    const callInstructionsLength = getCallInstructionsLength(contractCalls);
    const paddingLength = (8 - callInstructionsLength % 8) % 8;
    const paddedInstructionsLength = callInstructionsLength + paddingLength;
    const dataOffset = calculateScriptDataBaseOffset(maxInputs.toNumber()) + paddedInstructionsLength;
    const paramOffsets = [];
    let segmentOffset = dataOffset;
    const scriptData = [];
    for (let i = 0; i < TOTAL_CALLS; i += 1) {
      const call2 = contractCalls[i];
      const amountOffset = segmentOffset;
      const assetIdOffset = amountOffset + import_abi_coder2.WORD_SIZE;
      const callDataOffset = assetIdOffset + import_abi_coder2.ASSET_ID_LEN;
      const encodedSelectorOffset = callDataOffset + import_abi_coder2.CONTRACT_ID_LEN + import_abi_coder2.WORD_SIZE + import_abi_coder2.WORD_SIZE;
      const encodedArgsOffset = encodedSelectorOffset + call2.fnSelectorBytes.byteLength;
      const encodedArgs = (0, import_utils3.arrayify)(call2.data);
      let gasForwardedOffset = 0;
      scriptData.push(new import_abi_coder2.BigNumberCoder("u64").encode(call2.amount || 0));
      scriptData.push(new import_abi_coder2.B256Coder().encode(call2.assetId?.toString() || import_configs.ZeroBytes32));
      scriptData.push(call2.contractId.toBytes());
      scriptData.push(new import_abi_coder2.BigNumberCoder("u64").encode(encodedSelectorOffset));
      scriptData.push(new import_abi_coder2.BigNumberCoder("u64").encode(encodedArgsOffset));
      scriptData.push(call2.fnSelectorBytes);
      scriptData.push(encodedArgs);
      if (call2.gas) {
        scriptData.push(new import_abi_coder2.BigNumberCoder("u64").encode(call2.gas));
        gasForwardedOffset = encodedArgsOffset + encodedArgs.byteLength;
      }
      const callParamOffsets = {
        amountOffset,
        assetIdOffset,
        gasForwardedOffset,
        callDataOffset
      };
      paramOffsets.push(callParamOffsets);
      segmentOffset = dataOffset + (0, import_utils3.concat)(scriptData).byteLength;
    }
    const script = getInstructions(paramOffsets);
    const finalScriptData = (0, import_utils3.concat)(scriptData);
    return { data: finalScriptData, script };
  },
  () => [new Uint8Array()]
);

// src/functions/invocation-results.ts
var import_account2 = require("@fuel-ts/account");
var import_math2 = require("@fuel-ts/math");
var import_transactions3 = require("@fuel-ts/transactions");
function getGasUsage(callResult) {
  const scriptResult = callResult.receipts.find((r) => r.type === import_transactions3.ReceiptType.ScriptResult);
  return scriptResult?.gasUsed || (0, import_math2.bn)(0);
}
var InvocationResult = class {
  functionScopes;
  isMultiCall;
  gasUsed;
  value;
  /**
   * Constructs an instance of InvocationResult.
   *
   * @param funcScopes - The function scopes.
   * @param callResult - The call result.
   * @param isMultiCall - Whether it's a multi-call.
   */
  constructor(funcScopes, callResult, isMultiCall) {
    this.functionScopes = Array.isArray(funcScopes) ? funcScopes : [funcScopes];
    this.isMultiCall = isMultiCall;
    this.value = this.getDecodedValue(callResult);
    this.gasUsed = getGasUsage(callResult);
  }
  /**
   * Gets the first call config.
   *
   * @returns The first call config.
   */
  getFirstCallConfig() {
    if (!this.functionScopes[0]) {
      return void 0;
    }
    return this.functionScopes[0].getCallConfig();
  }
  /**
   * Gets the ABI from all calls.
   *
   * @returns The ABIs from all calls.
   */
  getAbiFromAllCalls() {
    return getAbisFromAllCalls(this.functionScopes);
  }
  /**
   * Decodes the value from the call result.
   *
   * @param callResult - The call result.
   * @returns The decoded value.
   */
  getDecodedValue(callResult) {
    const logs = this.getDecodedLogs(callResult.receipts);
    const callConfig = this.getFirstCallConfig();
    if (this.functionScopes.length === 1 && callConfig && "bytes" in callConfig.program) {
      return callResultToInvocationResult(callResult, callConfig, logs);
    }
    const encodedResults = decodeContractCallScriptResult(
      callResult,
      (callConfig?.program).id,
      logs
    );
    const returnValues = encodedResults.map((encodedResult, i) => {
      const { func } = this.functionScopes[i].getCallConfig();
      return func.decodeOutput(encodedResult)?.[0];
    });
    return this.isMultiCall ? returnValues : returnValues?.[0];
  }
  /**
   * Decodes the logs from the receipts.
   *
   * @param receipts - The transaction result receipts.
   * @returns The decoded logs.
   */
  getDecodedLogs(receipts) {
    const mainCallConfig = this.getFirstCallConfig();
    if (!mainCallConfig) {
      return [];
    }
    const { main, otherContractsAbis } = this.getAbiFromAllCalls();
    return (0, import_account2.getDecodedLogs)(receipts, main, otherContractsAbis);
  }
};
var FunctionInvocationResult = class extends InvocationResult {
  transactionId;
  transactionResponse;
  transactionResult;
  program;
  logs;
  /**
   * Constructs an instance of FunctionInvocationResult.
   *
   * @param funcScopes - The function scopes.
   * @param transactionResponse - The transaction response.
   * @param transactionResult - The transaction result.
   * @param program - The program.
   * @param isMultiCall - Whether it's a multi-call.
   */
  constructor(funcScopes, transactionResponse, transactionResult, program, isMultiCall) {
    super(funcScopes, transactionResult, isMultiCall);
    this.transactionResponse = transactionResponse;
    this.transactionResult = transactionResult;
    this.transactionId = this.transactionResponse.id;
    this.program = program;
    this.logs = this.getDecodedLogs(transactionResult.receipts);
  }
  /**
   * Builds an instance of FunctionInvocationResult.
   *
   * @param funcScope - The function scope.
   * @param transactionResponse - The transaction response.
   * @param isMultiCall - Whether it's a multi-call.
   * @param program - The program.
   * @returns The function invocation result.
   */
  static async build(funcScope, transactionResponse, isMultiCall, program) {
    const txResult = await transactionResponse.waitForResult();
    const fnResult = new FunctionInvocationResult(
      funcScope,
      transactionResponse,
      txResult,
      program,
      isMultiCall
    );
    return fnResult;
  }
};
var InvocationCallResult = class extends InvocationResult {
  callResult;
  /**
   * Constructs an instance of InvocationCallResult.
   *
   * @param funcScopes - The function scopes.
   * @param callResult - The call result.
   * @param isMultiCall - Whether it's a multi-call.
   */
  constructor(funcScopes, callResult, isMultiCall) {
    super(funcScopes, callResult, isMultiCall);
    this.callResult = callResult;
  }
  /**
   * Builds an instance of InvocationCallResult.
   *
   * @param funcScopes - The function scopes.
   * @param callResult - The call result.
   * @param isMultiCall - Whether it's a multi-call.
   * @returns The invocation call result.
   */
  static async build(funcScopes, callResult, isMultiCall) {
    const fnResult = await new InvocationCallResult(funcScopes, callResult, isMultiCall);
    return fnResult;
  }
};

// src/functions/base-invocation-scope.ts
function createContractCall(funcScope) {
  const { program, args, forward, func, callParameters, externalAbis } = funcScope.getCallConfig();
  const data = func.encodeArguments(args);
  return {
    contractId: program.id,
    fnSelector: func.selector,
    fnSelectorBytes: func.selectorBytes,
    encoding: func.encoding,
    data,
    assetId: forward?.assetId,
    amount: forward?.amount,
    gas: callParameters?.gasLimit,
    externalContractsAbis: externalAbis
  };
}
var BaseInvocationScope = class {
  transactionRequest;
  program;
  functionInvocationScopes = [];
  txParameters;
  requiredCoins = [];
  isMultiCall = false;
  hasCallParamsGasLimit = false;
  // flag to check if any of the callParams has gasLimit set
  externalAbis = {};
  addSignersCallback;
  /**
   * Constructs an instance of BaseInvocationScope.
   *
   * @param program - The abstract program to be invoked.
   * @param isMultiCall - A flag indicating whether the invocation is a multi-call.
   */
  constructor(program, isMultiCall) {
    this.program = program;
    this.isMultiCall = isMultiCall;
    this.transactionRequest = new import_account3.ScriptTransactionRequest();
  }
  /**
   * Getter for the contract calls.
   *
   * @returns An array of contract calls.
   */
  get calls() {
    const provider = this.getProvider();
    const consensusParams = provider.getChain();
    if (!consensusParams) {
      throw new import_errors4.FuelError(
        import_errors4.FuelError.CODES.CHAIN_INFO_CACHE_EMPTY,
        "Provider chain info cache is empty. Please make sure to initialize the `Provider` properly by running `await Provider.create()``"
      );
    }
    return this.functionInvocationScopes.map((funcScope) => createContractCall(funcScope));
  }
  /**
   * Updates the script request with the current contract calls.
   */
  updateScriptRequest() {
    const provider = this.getProvider();
    const {
      consensusParameters: {
        txParameters: { maxInputs }
      }
    } = provider.getChain();
    const contractCallScript = getContractCallScript(this.functionInvocationScopes, maxInputs);
    this.transactionRequest.setScript(contractCallScript, this.calls);
  }
  /**
   * Updates the transaction request with the current input/output.
   */
  updateContractInputAndOutput() {
    const calls = this.calls;
    calls.forEach((c) => {
      if (c.contractId) {
        this.transactionRequest.addContractInputAndOutput(c.contractId);
      }
      if (c.externalContractsAbis) {
        Object.keys(c.externalContractsAbis).forEach(
          (contractId) => this.transactionRequest.addContractInputAndOutput(import_address.Address.fromB256(contractId))
        );
      }
    });
  }
  /**
   * Gets the required coins for the transaction.
   *
   * @returns An array of required coin quantities.
   */
  getRequiredCoins() {
    const forwardingAssets = this.calls.map((call2) => ({
      assetId: String(call2.assetId),
      amount: (0, import_math3.bn)(call2.amount || 0)
    })).filter(({ assetId, amount }) => assetId && !(0, import_math3.bn)(amount).isZero());
    return forwardingAssets;
  }
  /**
   * Updates the required coins for the transaction.
   */
  updateRequiredCoins() {
    const assets = this.getRequiredCoins();
    const reduceForwardCoins = (requiredCoins, { assetId, amount }) => {
      const currentAmount = requiredCoins.get(assetId)?.amount || (0, import_math3.bn)(0);
      return requiredCoins.set(assetId, {
        assetId: String(assetId),
        amount: currentAmount.add(amount)
      });
    };
    this.requiredCoins = Array.from(
      assets.reduce(reduceForwardCoins, /* @__PURE__ */ new Map()).values()
    );
  }
  /**
   * Adds a single call to the invocation scope.
   *
   * @param funcScope - The function scope to add.
   * @returns The current instance of the class.
   */
  addCall(funcScope) {
    this.addCalls([funcScope]);
    return this;
  }
  /**
   * Adds multiple calls to the invocation scope.
   *
   * @param funcScopes - An array of function scopes to add.
   * @returns The current instance of the class.
   */
  addCalls(funcScopes) {
    this.functionInvocationScopes.push(...funcScopes);
    this.updateContractInputAndOutput();
    this.updateRequiredCoins();
    return this;
  }
  /**
   * Prepares the transaction by updating the script request, required coins, and checking the gas limit.
   */
  async prepareTransaction() {
    await asm2.initWasm();
    this.updateScriptRequest();
    this.updateRequiredCoins();
    this.checkGasLimitTotal();
    if (this.transactionRequest.type === import_transactions4.TransactionType.Script) {
      this.transactionRequest.abis = getAbisFromAllCalls(this.functionInvocationScopes);
    }
  }
  /**
   * Checks if the total gas limit is within the acceptable range.
   */
  checkGasLimitTotal() {
    const gasLimitOnCalls = this.calls.reduce((total, call2) => total.add(call2.gas || 0), (0, import_math3.bn)(0));
    if (this.transactionRequest.gasLimit.eq(0)) {
      this.transactionRequest.gasLimit = gasLimitOnCalls;
    } else if (gasLimitOnCalls.gt(this.transactionRequest.gasLimit)) {
      throw new import_errors4.FuelError(
        import_errors4.ErrorCode.TRANSACTION_ERROR,
        "Transaction's gasLimit must be equal to or greater than the combined forwarded gas of all calls."
      );
    }
  }
  /**
   * Gets the transaction cost ny dry running the transaction.
   *
   * @param options - Optional transaction cost options.
   * @returns The transaction cost details.
   */
  async getTransactionCost() {
    const provider = this.getProvider();
    const request = await this.getTransactionRequest();
    const txCost = await provider.getTransactionCost(request, {
      resourcesOwner: this.program.account,
      quantitiesToContract: this.getRequiredCoins(),
      signatureCallback: this.addSignersCallback
    });
    return txCost;
  }
  /**
   * Funds the transaction with the required coins.
   *
   * @returns The current instance of the class.
   */
  async fundWithRequiredCoins() {
    let transactionRequest = await this.getTransactionRequest();
    transactionRequest = (0, import_ramda.clone)(transactionRequest);
    const txCost = await this.getTransactionCost();
    const { gasUsed, missingContractIds, outputVariables, maxFee } = txCost;
    this.setDefaultTxParams(transactionRequest, gasUsed, maxFee);
    transactionRequest.inputs = transactionRequest.inputs.filter((i) => i.type !== import_transactions4.InputType.Coin);
    missingContractIds.forEach((contractId) => {
      transactionRequest.addContractInputAndOutput(import_address.Address.fromString(contractId));
    });
    transactionRequest.addVariableOutputs(outputVariables);
    await this.program.account?.fund(transactionRequest, txCost);
    if (this.addSignersCallback) {
      await this.addSignersCallback(transactionRequest);
    }
    return transactionRequest;
  }
  /**
   * Sets the transaction parameters.
   *
   * @param txParams - The transaction parameters to set.
   * @returns The current instance of the class.
   */
  txParams(txParams) {
    this.txParameters = txParams;
    const request = this.transactionRequest;
    request.tip = (0, import_math3.bn)(txParams.tip || request.tip);
    request.gasLimit = (0, import_math3.bn)(txParams.gasLimit || request.gasLimit);
    request.maxFee = txParams.maxFee ? (0, import_math3.bn)(txParams.maxFee) : request.maxFee;
    request.witnessLimit = txParams.witnessLimit ? (0, import_math3.bn)(txParams.witnessLimit) : request.witnessLimit;
    request.maturity = txParams.maturity || request.maturity;
    request.addVariableOutputs(this.txParameters?.variableOutputs || 0);
    return this;
  }
  /**
   * Adds contracts to the invocation scope.
   *
   * @param contracts - An array of contracts to add.
   * @returns The current instance of the class.
   */
  addContracts(contracts) {
    contracts.forEach((contract) => {
      this.transactionRequest.addContractInputAndOutput(contract.id);
      this.externalAbis[contract.id.toB256()] = contract.interface.jsonAbi;
    });
    return this;
  }
  /**
   * Adds an asset transfer to an Account on the contract call transaction request.
   *
   * @param transferParams - The object representing the transfer to be made.
   * @returns The current instance of the class.
   */
  addTransfer(transferParams) {
    const { amount, destination, assetId } = transferParams;
    const baseAssetId = this.getProvider().getBaseAssetId();
    this.transactionRequest = this.transactionRequest.addCoinOutput(
      import_address.Address.fromAddressOrString(destination),
      amount,
      assetId || baseAssetId
    );
    return this;
  }
  /**
   * Adds multiple transfers to the contract call transaction request.
   *
   * @param transferParams - An array of `TransferParams` objects representing the transfers to be made.
   * @returns The current instance of the class.
   */
  addBatchTransfer(transferParams) {
    const baseAssetId = this.getProvider().getBaseAssetId();
    transferParams.forEach(({ destination, amount, assetId }) => {
      this.transactionRequest = this.transactionRequest.addCoinOutput(
        import_address.Address.fromAddressOrString(destination),
        amount,
        assetId || baseAssetId
      );
    });
    return this;
  }
  addSigners(signers) {
    this.addSignersCallback = async (transactionRequest) => transactionRequest.addAccountWitnesses(signers);
    return this;
  }
  /**
   * Prepares and returns the transaction request object.
   *
   * @returns The prepared transaction request.
   */
  async getTransactionRequest() {
    await this.prepareTransaction();
    return this.transactionRequest;
  }
  /**
   * Submits a transaction.
   *
   * @returns The result of the function invocation.
   */
  async call() {
    assert(this.program.account, "Wallet is required!");
    const transactionRequest = await this.fundWithRequiredCoins();
    const response = await this.program.account.sendTransaction(transactionRequest, {
      awaitExecution: true,
      estimateTxDependencies: false
    });
    return FunctionInvocationResult.build(
      this.functionInvocationScopes,
      response,
      this.isMultiCall,
      this.program
    );
  }
  /**
   * Simulates a transaction.
   *
   * @returns The result of the invocation call.
   */
  async simulate() {
    assert(this.program.account, "Wallet is required!");
    if (!("populateTransactionWitnessesSignature" in this.program.account)) {
      throw new import_errors4.FuelError(
        import_errors4.ErrorCode.ABI_MAIN_METHOD_MISSING,
        "An unlocked wallet is required to simulate a contract call."
      );
    }
    const transactionRequest = await this.fundWithRequiredCoins();
    const result = await this.program.account.simulateTransaction(transactionRequest, {
      estimateTxDependencies: false
    });
    return InvocationCallResult.build(this.functionInvocationScopes, result, this.isMultiCall);
  }
  /**
   * Executes a transaction in dry run mode.
   *
   * @returns The result of the invocation call.
   */
  async dryRun() {
    const { receipts } = await this.getTransactionCost();
    const callResult = {
      receipts
    };
    return InvocationCallResult.build(
      this.functionInvocationScopes,
      callResult,
      this.isMultiCall
    );
  }
  async get() {
    const { receipts } = await this.getTransactionCost();
    const callResult = {
      receipts
    };
    return InvocationCallResult.build(
      this.functionInvocationScopes,
      callResult,
      this.isMultiCall
    );
  }
  getProvider() {
    const provider = this.program.provider;
    return provider;
  }
  /**
   * Obtains the ID of a transaction.
   *
   * @param chainId - the chainId to use to hash the transaction with
   * @returns the ID of the transaction.
   */
  async getTransactionId(chainId) {
    const chainIdToHash = chainId ?? await this.getProvider().getChainId();
    const transactionRequest = await this.getTransactionRequest();
    return transactionRequest.getTransactionId(chainIdToHash);
  }
  /**
   * In case the gasLimit is *not* set by the user, this method sets a default value.
   */
  setDefaultTxParams(transactionRequest, gasUsed, maxFee) {
    const gasLimitSpecified = (0, import_utils5.isDefined)(this.txParameters?.gasLimit) || this.hasCallParamsGasLimit;
    const maxFeeSpecified = (0, import_utils5.isDefined)(this.txParameters?.maxFee);
    const { gasLimit: setGasLimit, maxFee: setMaxFee } = transactionRequest;
    if (!gasLimitSpecified) {
      transactionRequest.gasLimit = gasUsed;
    } else if (setGasLimit.lt(gasUsed)) {
      throw new import_errors4.FuelError(
        import_errors4.ErrorCode.GAS_LIMIT_TOO_LOW,
        `Gas limit '${setGasLimit}' is lower than the required: '${gasUsed}'.`
      );
    }
    if (!maxFeeSpecified) {
      transactionRequest.maxFee = maxFee;
    } else if (maxFee.gt(setMaxFee)) {
      throw new import_errors4.FuelError(
        import_errors4.ErrorCode.MAX_FEE_TOO_LOW,
        `Max fee '${setMaxFee}' is lower than the required: '${maxFee}'.`
      );
    }
  }
};

// src/functions/invocation-scope.ts
var FunctionInvocationScope = class extends BaseInvocationScope {
  func;
  callParameters;
  forward;
  args;
  /**
   * Constructs an instance of FunctionInvocationScope.
   *
   * @param program - The program.
   * @param func - The function fragment.
   * @param args - The arguments.
   */
  constructor(program, func, args) {
    super(program, false);
    this.func = func;
    this.args = args || [];
    this.setArguments(...args);
    super.addCall(this);
  }
  /**
   * Gets the call configuration.
   *
   * @returns The call configuration.
   */
  getCallConfig() {
    return {
      func: this.func,
      program: this.program,
      callParameters: this.callParameters,
      txParameters: this.txParameters,
      forward: this.forward,
      args: this.args,
      externalAbis: this.externalAbis
    };
  }
  /**
   * Sets the arguments for the function invocation.
   *
   * @param args - The arguments.
   * @returns The instance of FunctionInvocationScope.
   */
  setArguments(...args) {
    this.args = args || [];
    return this;
  }
  /**
   * Sets the call parameters for the function invocation.
   *
   * @param callParams - The call parameters.
   * @returns The instance of FunctionInvocationScope.
   * @throws If the function is not payable and forward is set.
   */
  callParams(callParams) {
    if (!this.hasCallParamsGasLimit && callParams?.gasLimit !== void 0) {
      this.hasCallParamsGasLimit = true;
    }
    this.callParameters = callParams;
    if (callParams?.forward) {
      if (!this.func.attributes.find((attr) => attr.name === "payable")) {
        throw new import_errors5.FuelError(
          import_errors5.ErrorCode.TRANSACTION_ERROR,
          `The target function ${this.func.name} cannot accept forwarded funds as it's not marked as 'payable'.`
        );
      }
      this.forward = (0, import_account4.coinQuantityfy)(callParams.forward);
    }
    this.setArguments(...this.args);
    this.updateRequiredCoins();
    return this;
  }
};

// src/functions/multicall-scope.ts
var MultiCallInvocationScope = class extends BaseInvocationScope {
  /**
   * Constructs an instance of MultiCallInvocationScope.
   *
   * @param contract - The contract.
   * @param funcScopes - An array of function invocation scopes.
   */
  constructor(contract, funcScopes) {
    super(contract, true);
    this.addCalls(funcScopes);
  }
  /**
   * Adds a single function invocation scope to the multi-call invocation scope.
   *
   * @param funcScope - The function invocation scope.
   * @returns The instance of MultiCallInvocationScope.
   */
  addCall(funcScope) {
    return super.addCalls([funcScope]);
  }
  /**
   * Adds multiple function invocation scopes to the multi-call invocation scope.
   *
   * @param funcScopes - An array of function invocation scopes.
   * @returns The instance of MultiCallInvocationScope.
   */
  addCalls(funcScopes) {
    return super.addCalls(funcScopes);
  }
};

// src/contract.ts
var import_abi_coder3 = require("@fuel-ts/abi-coder");
var import_address2 = require("@fuel-ts/address");
var Contract = class {
  /**
   * The unique contract identifier.
   */
  id;
  /**
   * The provider for interacting with the contract.
   */
  provider;
  /**
   * The contract's ABI interface.
   */
  interface;
  /**
   * The account associated with the contract, if available.
   */
  account;
  /**
   * A collection of functions available on the contract.
   */
  functions = {};
  /**
   * Creates an instance of the Contract class.
   *
   * @param id - The contract's address.
   * @param abi - The contract's ABI (JSON ABI or Interface instance).
   * @param accountOrProvider - The account or provider for interaction.
   */
  constructor(id, abi, accountOrProvider) {
    this.interface = abi instanceof import_abi_coder3.Interface ? abi : new import_abi_coder3.Interface(abi);
    this.id = import_address2.Address.fromAddressOrString(id);
    if (accountOrProvider && "provider" in accountOrProvider) {
      this.provider = accountOrProvider.provider;
      this.account = accountOrProvider;
    } else {
      this.provider = accountOrProvider;
      this.account = null;
    }
    Object.keys(this.interface.functions).forEach((name) => {
      const fragment = this.interface.getFunction(name);
      Object.defineProperty(this.functions, fragment.name, {
        value: this.buildFunction(fragment),
        writable: false
      });
    });
  }
  /**
   * Build a function invocation scope for the provided function fragment.
   *
   * @param func - The function fragment to build a scope for.
   * @returns A function that creates a FunctionInvocationScope.
   */
  buildFunction(func) {
    return (() => {
      const funcInvocationScopeCreator = (...args) => new FunctionInvocationScope(this, func, args);
      Object.defineProperty(funcInvocationScopeCreator, "isReadOnly", {
        value: () => func.isReadOnly(),
        writable: false
      });
      return funcInvocationScopeCreator;
    })();
  }
  /**
   * Create a multi-call invocation scope for the provided function invocation scopes.
   *
   * @param calls - An array of FunctionInvocationScopes to execute in a batch.
   * @returns A MultiCallInvocationScope instance.
   */
  multiCall(calls) {
    return new MultiCallInvocationScope(this, calls);
  }
  /**
   * Get the balance for a given asset ID for this contract.
   *
   * @param assetId - The specified asset ID.
   * @returns The balance of the contract for the specified asset.
   */
  // #region contract-balance-1
  getBalance(assetId) {
    return this.provider.getContractBalance(this.id, assetId);
  }
  // #endregion contract-balance-1
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Contract,
  FunctionInvocationResult,
  FunctionInvocationScope,
  InstructionSet,
  InvocationCallResult,
  InvocationResult,
  MultiCallInvocationScope,
  ScriptRequest,
  assert,
  getAbisFromAllCalls
});
//# sourceMappingURL=index.js.map