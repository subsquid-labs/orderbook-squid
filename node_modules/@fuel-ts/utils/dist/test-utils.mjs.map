{"version":3,"sources":["../src/test-utils/getForcProject.ts","../src/utils/arrayify.ts","../src/utils/hexlify.ts","../src/utils/normalizeString.ts","../src/utils/date-time.ts","../src/utils/base58.ts","../src/utils/dataSlice.ts","../src/utils/toUtf8Bytes.ts","../src/test-utils/expectToBeInRange.ts","../src/test-utils/constants.ts"],"sourcesContent":["import { existsSync, readFileSync } from 'fs';\nimport { join } from 'path';\n\nimport { hexlify } from '../index';\nimport { normalizeString } from '../utils/normalizeString';\n\ninterface IGetForcProjectParams {\n  projectDir: string;\n  projectName: string;\n  build: 'debug' | 'release';\n}\n\nexport const getProjectBuildDir = (params: IGetForcProjectParams) =>\n  join(params.projectDir, 'out', params.build);\nexport const getProjectReleaseDir = (params: IGetForcProjectParams) =>\n  join(params.projectDir, 'out', params.build);\nexport const getProjectTempDir = (params: IGetForcProjectParams) =>\n  join(getProjectBuildDir(params), '__temp__');\n\nexport const getProjectAbiPath = (params: IGetForcProjectParams) =>\n  join(getProjectBuildDir(params), `${params.projectName}-abi.json`);\n\nexport const getProjectBinPath = (params: IGetForcProjectParams) =>\n  join(getProjectBuildDir(params), `${params.projectName}.bin`);\n\nexport const getProjectStorageSlotsPath = (params: IGetForcProjectParams) =>\n  join(getProjectBuildDir(params), `${params.projectName}-storage_slots.json`);\n\nexport const getProjectAbiName = (params: IGetForcProjectParams) => `${params.projectName}-abi`;\n\nexport const getProjectNormalizedName = (params: IGetForcProjectParams) =>\n  normalizeString(params.projectName);\n\nexport const getProjectAbi = (params: IGetForcProjectParams) => {\n  const projectPath = getProjectAbiPath(params);\n  const abiContents = JSON.parse(readFileSync(projectPath, 'utf-8'));\n  return abiContents;\n};\n\nexport const getProjectStorageSlots = (params: IGetForcProjectParams) => {\n  const storageSlotsFilePath = getProjectStorageSlotsPath(params);\n  if (!existsSync(storageSlotsFilePath)) {\n    return [];\n  }\n  const storageSlots = JSON.parse(readFileSync(storageSlotsFilePath, 'utf-8'));\n  return storageSlots;\n};\n\nexport const getForcProject = <T = unknown>(params: IGetForcProjectParams) => {\n  const buildDir = getProjectBuildDir(params);\n  const tempDir = getProjectTempDir(params);\n  const binPath = getProjectBinPath(params);\n  const binHexlified = hexlify(readFileSync(binPath));\n  const abiPath = getProjectAbiPath(params);\n  const abiName = getProjectAbiName(params);\n  const abiContents: T = getProjectAbi(params);\n  const normalizedName = getProjectNormalizedName(params);\n  const storageSlots: Array<{\n    key: string;\n    value: string;\n  }> = getProjectStorageSlots(params);\n\n  const inputGlobal = `${buildDir}/*-abi.json`;\n\n  return {\n    name: params.projectName,\n    storageSlots,\n    normalizedName,\n    buildDir,\n    tempDir,\n    binPath,\n    binHexlified,\n    abiPath,\n    abiName,\n    abiContents,\n    inputGlobal,\n  };\n};\n","import { FuelError, ErrorCode } from '@fuel-ts/errors';\nimport type { BytesLike } from '@fuel-ts/interfaces';\n\n/**\n * Get a typed Uint8Array from a BytesLike object.\n *\n * @param value - the BytesLike data.\n * @param name - a display name for the error result.\n * @param copy - create a copy of the original data (if applicable).\n * @returns - a typed Uint8Array.\n */\nexport const arrayify = (value: BytesLike, name?: string, copy: boolean = true): Uint8Array => {\n  if (value instanceof Uint8Array) {\n    if (copy) {\n      return new Uint8Array(value);\n    }\n    return value;\n  }\n\n  if (typeof value === 'string' && value.match(/^0x([0-9a-f][0-9a-f])*$/i)) {\n    const result = new Uint8Array((value.length - 2) / 2);\n    let offset = 2;\n    for (let i = 0; i < result.length; i++) {\n      result[i] = parseInt(value.substring(offset, offset + 2), 16);\n      offset += 2;\n    }\n    return result;\n  }\n\n  const nameMessage = name ? ` ${name} -` : '';\n  const message = `invalid data:${nameMessage} ${value}\\nIf you are attempting to transform a hex value, please make sure it is being passed as a string and wrapped in quotes.`;\n  throw new FuelError(ErrorCode.INVALID_DATA, message);\n};\n","import type { BytesLike } from '@fuel-ts/interfaces';\n\nimport { arrayify } from './arrayify';\n\nconst HexCharacters: string = '0123456789abcdef';\n\n/**\n *  Returns a hex representation of the inputted bytes.\n */\nexport function hexlify(data: BytesLike): string {\n  const bytes = arrayify(data);\n\n  let result = '0x';\n  for (let i = 0; i < bytes.length; i++) {\n    const v = bytes[i];\n    result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n  }\n  return result;\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\n\n/**\n * Converts `some.string-value` into `SomeStringValue`.\n *\n * Examples:\n *  my-simple.test —— MySimpleTest\n *  myFile.ts —— MyFileTs\n *  my-abi.json —— MyAbiJson\n */\nexport const normalizeString = (str: string): string => {\n  const transformations: ((s: string) => string)[] = [\n    (s) => s.replace(/\\s+/g, '-'), // spaces to -\n    (s) => s.replace(/\\./g, '-'), // dots to -\n    (s) => s.replace(/_/g, '-'), // underscore to -\n    (s) => s.replace(/-[a-z]/g, (match) => match.slice(-1).toUpperCase()), // delete '-' and capitalize the letter after them\n    (s) => s.replace(/-/g, ''), // delete any '-' left\n    (s) => s.replace(/^\\d+/, ''), // removes leading digits\n    (s) => s[0].toUpperCase() + s.slice(1), // capitalize first letter\n  ];\n\n  const output = transformations.reduce((s, t) => t(s), str);\n\n  if (output === '') {\n    const errMsg = `The provided string '${str}' results in an empty output after`.concat(\n      ` normalization, therefore, it can't normalize string.`\n    );\n    throw new FuelError(ErrorCode.PARSE_FAILED, errMsg);\n  }\n\n  return output;\n};\n","/**\n * Tai64 timestamp.\n */\ntype Tai64Timestamp = string;\n\n/**\n * This constant is used to calculate the offset between the Unix epoch and the TAI64 epoch.\n * It allows for a **rough** conversion between the two time formats.\n *\n * // Value expires on:  28 June 2024\n * {@link https://data.iana.org/time-zones/data/leap-seconds.list}\n * {@link https://github.com/hl2/tai64/blob/master/src/leapSeconds.ts}\n */\nconst TAI64_LEAP_SECONDS: number = 37;\n\n/**\n * Tai64 (Temps Atomique International) is a time format\n *\n * The offset between the Unix epoch and the TAI64 epoch.\n * The TAI64 epoch is 2^62 nanoseconds after the Unix epoch (+ the offset of \"leap seconds\" relevant to the date).\n *\n * {@link https://cr.yp.to/libtai/tai64.html}\n * {@link https://cr.yp.to/proto/tai64.txt}\n */\nconst TAI64_UNIX_OFFSET: bigint = BigInt(2 ** 62) + BigInt(TAI64_LEAP_SECONDS);\n\n/**\n * Converts milliseconds to seconds and vice versa.\n *\n * @param ms - milliseconds to convert\n * @returns seconds\n */\nconst msToSeconds = (ms: number): number => Math.floor(ms / 1000);\n\n/**\n * Converts seconds to milliseconds and vice versa.\n *\n * @param seconds - seconds to convert\n * @returns milliseconds\n */\nconst secondsToMs = (seconds: number): number => seconds * 1000;\n\n/**\n * Converts Tai64 (seconds) time units to UNIX (seconds) time units.\n *\n * @param tai64 - Tai64 timestamp\n * @returns Unix seconds timestamp\n */\nconst tai64ToUnixSeconds = (tai64: Tai64Timestamp): number =>\n  Number(BigInt(tai64) - TAI64_UNIX_OFFSET);\n\n/**\n * Converts Unix (seconds) to Tai64 (seconds).\n *\n * @param unixSeconds - unix seconds timestamp\n * @returns Tai64 timestamp\n */\nconst unixSecondsToTai64 = (unixSeconds: number): string =>\n  String(BigInt(unixSeconds) + TAI64_UNIX_OFFSET);\n\n/**\n * Helper to convert Tai64 (seconds) time units to UNIX (milliseconds) time units and vice.\n *\n * @param tai64 - Tai64 timestamp\n * @returns Unix milliseconds timestamp\n */\nconst tai64ToUnixMilliseconds = (tai64: Tai64Timestamp): number =>\n  secondsToMs(tai64ToUnixSeconds(tai64));\n\n/**\n * This class is used to represent a date and time in the Tai64 format.\n *\n * ```typescript\n * import { DateTime } from 'fuels';\n *\n * // Constants\n * const tai64 = '4611686020108779340';\n * const unixMilliseconds = 1681391398000;\n * const seconds = 1681391398;\n *\n * // Instantiation\n * let date: DateTime = DateTime.now();\n * date = DateTime.fromTai64(tai64);\n * date = DateTime.fromUnixMilliseconds(unixMilliseconds);\n * date = DateTime.fromUnixSeconds(seconds);\n *\n * // Utility functions\n * tai64.toTai64() // '4611686020108779340'\n * milliseconds.toUnixMilliseconds() // 1681391398000\n * seconds.toUnixSeconds() // 1681391398\n *\n * // All date methods are available\n * const now: Date = DateTime.now();\n * now.toISOString(); // '2023-04-13T13:09:58.000Z'\n * now.getTime(); // 1681391398000\n * ```\n */\nexport class DateTime extends Date implements Date {\n  static TAI64_NULL: Tai64Timestamp = '';\n\n  /**\n   * Generates a new DateTime instance from a Tai64 timestamp.\n   *\n   * @param tai64 - Tai64 timestamp\n   * @returns a new DateTime instance\n   */\n  static fromTai64(tai64: Tai64Timestamp): DateTime {\n    return new DateTime(tai64ToUnixMilliseconds(tai64));\n  }\n\n  /**\n   * @param unixMilliseconds - unix milliseconds timestamp\n   * @returns a new DateTime instance\n   */\n  static fromUnixMilliseconds(unixMilliseconds: number): DateTime {\n    return new DateTime(unixMilliseconds);\n  }\n\n  /**\n   * @param unixSeconds - unix seconds timestamp\n   * @returns a new DateTime instance\n   */\n  static fromUnixSeconds(unixSeconds: number): DateTime {\n    return new DateTime(secondsToMs(unixSeconds));\n  }\n\n  /**\n   * Hide the constructor to prevent direct instantiation.\n   */\n  private constructor(date: Date | number | string) {\n    super(date);\n  }\n\n  /**\n   * Returns the Tai64 timestamp.\n   *\n   * @returns the Tai64 timestamp\n   */\n  toTai64(): Tai64Timestamp {\n    return unixSecondsToTai64(this.toUnixSeconds());\n  }\n\n  /**\n   * @returns the unix milliseconds timestamp\n   */\n  toUnixMilliseconds(): number {\n    return this.getTime();\n  }\n\n  /**\n   * @returns the unix seconds timestamp\n   */\n  toUnixSeconds(): number {\n    return msToSeconds(this.getTime());\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport type { BytesLike } from '@fuel-ts/interfaces';\nimport type { BN } from '@fuel-ts/math';\nimport { bn } from '@fuel-ts/math';\n\nimport { arrayify } from './arrayify';\n\nconst BN_0 = bn(0);\nconst BN_58 = bn(58);\nconst Alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\nlet Lookup: null | Record<string, BN> = null;\n\nfunction getAlpha(letter: string): BN {\n  if (Lookup == null) {\n    Lookup = {};\n    for (let i = 0; i < Alphabet.length; i++) {\n      Lookup[Alphabet[i]] = bn(i);\n    }\n  }\n  const result = Lookup[letter];\n  if (result == null) {\n    throw new FuelError(ErrorCode.INVALID_DATA, `invalid base58 value ${letter}`);\n  }\n  return bn(result);\n}\n\n/**\n *  Encode value as a Base58-encoded string.\n */\nexport function encodeBase58(_value: BytesLike): string {\n  const bytes = arrayify(_value);\n\n  let value = bn(bytes);\n  let result = '';\n  while (value.gt(BN_0)) {\n    result = Alphabet[Number(value.mod(BN_58))] + result;\n    value = value.div(BN_58);\n  }\n\n  // Account for leading padding zeros\n  for (let i = 0; i < bytes.length; i++) {\n    if (bytes[i]) {\n      break;\n    }\n    result = Alphabet[0] + result;\n  }\n\n  return result;\n}\n\nexport function decodeBase58(value: string): BN {\n  let result = BN_0;\n  for (let i = 0; i < value.length; i++) {\n    result = result.mul(BN_58);\n    result = result.add(getAlpha(value[i].toString()));\n  }\n  return result;\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport type { BytesLike } from '@fuel-ts/interfaces';\n\nimport { arrayify } from './arrayify';\nimport { hexlify } from './hexlify';\n\n/**\n *  Returns a hex string by slicing data from the start offset to the end offset.\n *\n * @param data - the data to be sliced.\n * @param start - the start offset (default: 0).\n * @param end - the end offset (default: length of data).\n * @returns - a sliced hex string from start to end.\n */\nexport function dataSlice(data: BytesLike, start?: number, end?: number): string {\n  const bytes = arrayify(data);\n  if (end != null && end > bytes.length) {\n    throw new FuelError(ErrorCode.INVALID_DATA, 'cannot slice beyond data bounds');\n  }\n  return hexlify(bytes.slice(start == null ? 0 : start, end == null ? bytes.length : end));\n}\n","import { FuelError, ErrorCode } from '@fuel-ts/errors';\n\n/**\n *  Returns the UTF-8 byte representation of str.\n *\n *  If form is disabled, the string is not normalized.\n * @param stri - the string to convert to UTF-8 bytes.\n * @param form - whether to normalize the string.\n * @returns - the UTF-8 byte representation of str.\n */\nexport function toUtf8Bytes(stri: string, form = true): Uint8Array {\n  let str = stri;\n\n  if (form) {\n    str = stri.normalize('NFC');\n  }\n\n  const result: Array<number> = [];\n\n  for (let i = 0; i < str.length; i += 1) {\n    const c = str.charCodeAt(i);\n\n    if (c < 0x80) {\n      result.push(c);\n    } else if (c < 0x800) {\n      result.push((c >> 6) | 0xc0);\n      result.push((c & 0x3f) | 0x80);\n    } else if ((c & 0xfc00) === 0xd800) {\n      i += 1;\n      const c2 = str.charCodeAt(i);\n\n      if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n        throw new FuelError(\n          ErrorCode.INVALID_INPUT_PARAMETERS,\n          'Invalid UTF-8 in the input string.'\n        );\n      }\n\n      // Surrogate Pair\n      const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n      result.push((pair >> 18) | 0xf0);\n      result.push(((pair >> 12) & 0x3f) | 0x80);\n      result.push(((pair >> 6) & 0x3f) | 0x80);\n      result.push((pair & 0x3f) | 0x80);\n    } else {\n      result.push((c >> 12) | 0xe0);\n      result.push(((c >> 6) & 0x3f) | 0x80);\n      result.push((c & 0x3f) | 0x80);\n    }\n  }\n\n  return new Uint8Array(result);\n}\n","export const expectToBeInRange = (params: { value: number; min: number; max: number }) => {\n  const { value, min, max } = params;\n  if (value >= min && value <= max) {\n    return true;\n  }\n\n  throw new Error(`Expected value: '${value}' to be within range: '${min}-${max}'`);\n};\n","export const ASSET_A: string = '0x0101010101010101010101010101010101010101010101010101010101010101';\nexport const ASSET_B: string = '0x0202020202020202020202020202020202020202020202020202020202020202';\n"],"mappings":"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","names":["ErrorCode","FuelError","ErrorCode","FuelError","ErrorCode","FuelError","FuelError","ErrorCode"]}